{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "smart-form",
  "type": "registry:component",
  "title": "Smart Form",
  "description": "Entire form component with dynamic fields render on top of the configuration.",
  "dependencies": [
    "lucide-react",
    "@radix-ui/react-slot",
    "class-variance-authority",
    "@radix-ui/react-popover",
    "@radix-ui/react-checkbox",
    "cmdk",
    "@radix-ui/react-dialog",
    "@radix-ui/react-separator",
    "date-fns",
    "react-day-picker",
    "@tiptap/react",
    "@radix-ui/react-slider",
    "color",
    "@radix-ui/react-select",
    "@radix-ui/react-popover",
    "@radix-ui/react-tooltip",
    "@tiptap/extension-image",
    "@radix-ui/react-dropdown-menu",
    "@tiptap/extension-youtube",
    "html-react-parser",
    "lodash.throttle",
    "@hookform/resolvers",
    "react-dropzone",
    "react-hook-form",
    "sonner",
    "zod",
    "@radix-ui/react-label",
    "@radix-ui/react-tabs",
    "motion",
    "react-phone-number-input",
    "react-number-format"
  ],
  "registryDependencies": [
    "https://ntt-shadcn-registry.vercel.app/r/multi-select.json",
    "https://ntt-shadcn-registry.vercel.app/r/badge.json",
    "https://ntt-shadcn-registry.vercel.app/r/button.json",
    "https://ntt-shadcn-registry.vercel.app/r/checkbox.json",
    "https://ntt-shadcn-registry.vercel.app/r/command.json",
    "https://ntt-shadcn-registry.vercel.app/r/popover.json",
    "https://ntt-shadcn-registry.vercel.app/r/separator.json",
    "https://ntt-shadcn-registry.vercel.app/r/spinner.json",
    "https://ntt-shadcn-registry.vercel.app/r/dialog.json",
    "https://ntt-shadcn-registry.vercel.app/r/input.json",
    "https://ntt-shadcn-registry.vercel.app/r/input-group.json",
    "https://ntt-shadcn-registry.vercel.app/r/textarea.json",
    "https://ntt-shadcn-registry.vercel.app/r/calendar.json",
    "https://ntt-shadcn-registry.vercel.app/r/color-picker.json",
    "https://ntt-shadcn-registry.vercel.app/r/dropdown-menu.json",
    "https://ntt-shadcn-registry.vercel.app/r/skeleton.json",
    "https://ntt-shadcn-registry.vercel.app/r/label.json",
    "https://ntt-shadcn-registry.vercel.app/r/tooltip.json",
    "https://ntt-shadcn-registry.vercel.app/r/kbd.json",
    "https://ntt-shadcn-registry.vercel.app/r/field.json",
    "https://ntt-shadcn-registry.vercel.app/r/button-group.json",
    "https://ntt-shadcn-registry.vercel.app/r/combobox.json"
  ],
  "files": [
    {
      "path": "src/registry/new-york/organisms/smart-form/components/autocomplete-with-infinite-query-field.tsx",
      "content": "import React from 'react'\nimport { MultiSelect } from '@/components/molecules/multi-select'\nimport type { Option } from '@/types/base'\nimport FieldContainer, { type FieldProps } from './field-container'\n\n// Component\nconst AutocompleteWithInfiniteQueryField = ({ fieldData, disabledFields }: FieldProps) => {\n  // Todo: fetch infinite query and extract options\n\n  // Memos\n  const options = React.useMemo<Option[]>(() => {\n    return []\n  }, [])\n\n  // Template\n  return (\n    <FieldContainer fieldData={fieldData} disabledFields={disabledFields}>\n      {({ field }) => (\n        <MultiSelect\n          {...field}\n          options={options}\n          placeholder={`Select ${fieldData.label.toLowerCase()}`}\n          buttonTriggerProps={{\n            id: fieldData.code,\n            disabled: disabledFields?.[fieldData.code]\n          }}\n          onValueChange={field.onChange}\n        />\n      )}\n    </FieldContainer>\n  )\n}\n\nexport default AutocompleteWithInfiniteQueryField\n",
      "type": "registry:ui",
      "target": "src/components/organisms/smart-form/autocomplete-with-infinite-query-field.tsx"
    },
    {
      "path": "src/types/base.ts",
      "content": "export interface Option {\n  value: string\n  label: string\n}\n",
      "type": "registry:file",
      "target": "src/types/base.ts"
    },
    {
      "path": "src/registry/new-york/organisms/smart-form/components/autocomplete-with-options-field.tsx",
      "content": "import { Autocomplete } from '@/components/molecules/autocomplete'\nimport FieldContainer, { type FieldProps } from './field-container'\n\n// Component\nconst AutocompleteWithOptionsField = ({ fieldData, disabledFields }: FieldProps) => {\n  // Template\n  return (\n    <FieldContainer fieldData={fieldData} disabledFields={disabledFields}>\n      {({ field, fieldState }) => (\n        <Autocomplete\n          {...field}\n          options={fieldData.config?.options ?? []}\n          placeholder={`Enter ${fieldData.label.toLowerCase()}`}\n          inputProps={{\n            id: fieldData.code,\n            disabled: disabledFields?.[fieldData.code],\n            'aria-invalid': fieldState.invalid\n          }}\n          onValueChange={field.onChange}\n        />\n      )}\n    </FieldContainer>\n  )\n}\n\nexport default AutocompleteWithOptionsField\n",
      "type": "registry:ui",
      "target": "src/components/organisms/smart-form/autocomplete-with-options-field.tsx"
    },
    {
      "path": "src/registry/new-york/organisms/smart-form/components/autocomplete-with-query-field.tsx",
      "content": "import React from 'react'\nimport { MultiSelect } from '@/components/molecules/multi-select'\nimport type { Option } from '@/types/base'\nimport FieldContainer, { type FieldProps } from './field-container'\n\n// Component\nconst AutocompleteWithQueryField = ({ fieldData, disabledFields }: FieldProps) => {\n  // Todo: fetch query and extract options\n\n  // Memos\n  const options = React.useMemo<Option[]>(() => {\n    return []\n  }, [])\n\n  // Template\n  return (\n    <FieldContainer fieldData={fieldData} disabledFields={disabledFields}>\n      {({ field }) => (\n        <MultiSelect\n          {...field}\n          options={options}\n          placeholder={`Select ${fieldData.label.toLowerCase()}`}\n          buttonTriggerProps={{\n            id: fieldData.code,\n            disabled: disabledFields?.[fieldData.code]\n          }}\n          onValueChange={field.onChange}\n        />\n      )}\n    </FieldContainer>\n  )\n}\n\nexport default AutocompleteWithQueryField\n",
      "type": "registry:ui",
      "target": "src/components/organisms/smart-form/autocomplete-with-query-field.tsx"
    },
    {
      "path": "src/registry/new-york/organisms/smart-form/components/checkbox-field.tsx",
      "content": "import { Checkbox } from '@/components/ui/checkbox'\nimport FieldContainer, { type FieldProps } from './field-container'\n\n// Component\nconst CheckboxField = ({ fieldData, disabledFields }: FieldProps) => {\n  // Template\n  return (\n    <FieldContainer fieldData={fieldData} disabledFields={disabledFields}>\n      {({ field }) => (\n        <Checkbox\n          id={fieldData.code}\n          checked={field.value}\n          disabled={disabledFields?.[fieldData.code]}\n          onCheckedChange={field.onChange}\n        />\n      )}\n    </FieldContainer>\n  )\n}\n\nexport default CheckboxField\n",
      "type": "registry:ui",
      "target": "src/components/organisms/smart-form/checkbox-field.tsx"
    },
    {
      "path": "src/registry/new-york/organisms/smart-form/components/date-field.tsx",
      "content": "import { DatePicker } from '@/components/ui/date-picker'\nimport FieldContainer, { type FieldProps } from './field-container'\n\n// Component\nconst DateField = ({ fieldData, disabledFields }: FieldProps) => {\n  // Template\n  return (\n    <FieldContainer fieldData={fieldData} disabledFields={disabledFields}>\n      {({ field }) => (\n        <DatePicker\n          {...field}\n          id={fieldData.code}\n          placeholder={`Select ${fieldData.label.toLowerCase()}`}\n          isDisabled={disabledFields?.[fieldData.code]}\n          onValueChange={field.onChange}\n        />\n      )}\n    </FieldContainer>\n  )\n}\n\nexport default DateField\n",
      "type": "registry:ui",
      "target": "src/components/organisms/smart-form/date-field.tsx"
    },
    {
      "path": "src/registry/new-york/organisms/smart-form/components/editor-field.tsx",
      "content": "import { Editor } from '@/components/organisms/editor'\nimport FieldContainer, { type FieldProps } from './field-container'\n\n// Component\nconst EditorField = ({ fieldData, disabledFields }: FieldProps) => {\n  // Template\n  return (\n    <FieldContainer fieldData={fieldData} disabledFields={disabledFields}>\n      {({ field }) => (\n        <Editor value={field.value} editable={!disabledFields?.[fieldData.code]} onValueChange={field.onChange} />\n      )}\n    </FieldContainer>\n  )\n}\n\nexport default EditorField\n",
      "type": "registry:ui",
      "target": "src/components/organisms/smart-form/editor-field.tsx"
    },
    {
      "path": "src/registry/new-york/organisms/smart-form/components/field-container.tsx",
      "content": "import { Controller, type ControllerProps, type FieldPath, type FieldValues, useFormContext } from 'react-hook-form'\nimport { Field, FieldDescription, FieldError, FieldLabel } from '@/components/ui/field'\nimport { cn } from '@/utils/ui'\nimport type { SmartFormFieldData, SmartFormProps } from './lib'\n\nexport type FieldContainerProps<\n  TFieldValues extends FieldValues = FieldValues,\n  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,\n  TTransformedValues = TFieldValues\n> = Pick<SmartFormProps, 'disabledFields'> & {\n  fieldData: SmartFormFieldData\n  children: (\n    props: Pick<SmartFormProps, 'disabledFields'> &\n      Parameters<ControllerProps<TFieldValues, TName, TTransformedValues>['render']>[0] & {\n        fieldData: SmartFormFieldData\n      }\n  ) => React.ReactNode\n}\n\nexport type FieldProps = Omit<FieldContainerProps, 'children'>\n\n// Component\nconst FieldContainer = <\n  TFieldValues extends FieldValues = FieldValues,\n  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,\n  TTransformedValues = TFieldValues\n>({\n  fieldData,\n  disabledFields,\n  children\n}: FieldContainerProps<TFieldValues, TName, TTransformedValues>) => {\n  // Hooks\n  const form = useFormContext<TFieldValues, TName, TTransformedValues>()\n\n  // Template\n  return (\n    <Controller\n      control={form.control}\n      name={fieldData.code as TName}\n      render={({ field, fieldState, formState }) => {\n        return (\n          <Field\n            data-invalid={fieldState.invalid}\n            className={cn(\n              'group/field col-span-full',\n              {\n                'flex-row-reverse': fieldData.type === 'checkbox'\n              },\n              fieldData.className\n            )}\n            orientation={fieldData.type === 'checkbox' ? 'horizontal' : 'vertical'}\n          >\n            <FieldLabel htmlFor={fieldData.code}>\n              {fieldData.label} {fieldData.config?.validation?.required && '*'}\n            </FieldLabel>\n\n            {children({\n              field,\n              fieldState,\n              formState,\n              fieldData,\n              disabledFields\n            })}\n\n            {fieldData.description && <FieldDescription>{fieldData.description}</FieldDescription>}\n            {fieldState.invalid && <FieldError errors={[fieldState.error]} />}\n          </Field>\n        )\n      }}\n    />\n  )\n}\n\nexport default FieldContainer\n",
      "type": "registry:ui",
      "target": "src/components/organisms/smart-form/field-container.tsx"
    },
    {
      "path": "src/registry/new-york/organisms/smart-form/components/file-field.tsx",
      "content": "import { FileUpload, FileUploadContent, FileUploadInput, FileUploadItem } from '@/components/molecules/file-upload'\nimport FieldContainer, { type FieldProps } from './field-container'\n\n// Component\nconst FileField = ({ fieldData, disabledFields }: FieldProps) => {\n  // Template\n  return (\n    <FieldContainer fieldData={fieldData} disabledFields={disabledFields}>\n      {({ field, fieldState }) => (\n        <FileUpload\n          value={field.value ? [field.value] : []}\n          dropzoneOptions={fieldData.config?.dropzoneOptions}\n          isDisabled={disabledFields?.[fieldData.code]}\n          onValueChange={(files) => field.onChange(files[0] ?? null)}\n        >\n          <FileUploadInput id={fieldData.code} aria-invalid={fieldState.invalid} />\n\n          <FileUploadContent>{field.value && <FileUploadItem value={field.value} index={0} />}</FileUploadContent>\n        </FileUpload>\n      )}\n    </FieldContainer>\n  )\n}\n\nexport default FileField\n",
      "type": "registry:ui",
      "target": "src/components/organisms/smart-form/file-field.tsx"
    },
    {
      "path": "src/registry/new-york/organisms/smart-form/components/index.ts",
      "content": "export * from './lib'\nexport * from './smart-form'\n",
      "type": "registry:file",
      "target": "src/components/organisms/smart-form/index.ts"
    },
    {
      "path": "src/registry/new-york/organisms/smart-form/components/input-field.tsx",
      "content": "import { Input } from '@/components/ui/input'\nimport FieldContainer, { type FieldProps } from './field-container'\n\n// Component\nconst InputField = ({ fieldData, disabledFields }: FieldProps) => {\n  // Template\n  return (\n    <FieldContainer fieldData={fieldData} disabledFields={disabledFields}>\n      {({ field, fieldState }) => (\n        <Input\n          {...field}\n          id={fieldData.code}\n          placeholder={`Enter ${fieldData.label.toLowerCase()}`}\n          disabled={disabledFields?.[fieldData.code]}\n          aria-invalid={fieldState.invalid}\n        />\n      )}\n    </FieldContainer>\n  )\n}\n\nexport default InputField\n",
      "type": "registry:ui",
      "target": "src/components/organisms/smart-form/input-field.tsx"
    },
    {
      "path": "src/registry/new-york/organisms/smart-form/components/lib.ts",
      "content": "import { toDate } from 'date-fns'\nimport type { Accept } from 'react-dropzone'\nimport type { FieldValues, UseFormReturn } from 'react-hook-form'\nimport { isValidPhoneNumber } from 'react-phone-number-input'\nimport z, { type ZodArray, type ZodNullable, type ZodNumber, type ZodPipe, type ZodString, type ZodType } from 'zod'\nimport type { UploadedFile } from '@/components/molecules/file-upload'\nimport type { NumberInputProps } from '@/components/molecules/number-input'\nimport type { DatePickerProps } from '@/components/ui/date-picker'\nimport type { Option } from '@/types/base'\n\n// [T] Smart form data\nexport interface SmartFormData {\n  code: string\n  templates: Array<{\n    code: string\n    label: string\n    description?: string\n    className?: string\n    fields: Array<{\n      code: string\n      label: string\n      type:\n        | 'input'\n        | 'textarea'\n        | 'number'\n        | 'phone-number'\n        | 'password'\n        | 'select-with-options'\n        | 'select-with-query'\n        | 'select-with-infinite-query'\n        | 'multi-select-with-options'\n        | 'multi-select-with-query'\n        | 'multi-select-with-infinite-query'\n        | 'autocomplete-with-options'\n        | 'autocomplete-with-query'\n        | 'autocomplete-with-infinite-query'\n        | 'date'\n        | 'checkbox'\n        | 'radio'\n        | 'file'\n        | 'multi-file'\n        | 'editor'\n        | 'label'\n        | 'slot'\n      config?: {\n        validation?: Record<\n          string,\n          {\n            /**\n             * @field TEXT | TEXTAREA | PASSWORD | SELECT_OR_TEXT\n             * @type required (boolean), min (number), max (number), email (boolean), regex({pattern: string, flags: string}), phone(string[])\n             *\n             * @field PASSWORD\n             * @type required (boolean), min (number), max (number), regex({pattern: string, flags: string})\n             *\n             * @field SELECT | RADIO\n             * @type required (boolean)\n             *\n             * @field NUMBER\n             * @type min (number), max (number), negative (boolean), positive (boolean)\n             *\n             * @field MULTI_SELECT\n             * @type required (boolean)\n             *\n             * @field DATE\n             * @type required (boolean)\n             *\n             * @field FILE, MULTI_FILES\n             * @type required (boolean), max_size (number), mime_types (string[])\n             */\n            value: boolean | number | { pattern: string; flags: string } | string[]\n            message: string\n          }\n        >\n        referenceFields?: Array<{\n          code: string\n          key: string\n          message: string\n        }>\n        // Number\n        numberInputProps?: NumberInputProps\n        // Date\n        isPreviousDateDisabled?: boolean\n        isNextDateDisabled?: boolean\n        datePickerProps?: DatePickerProps\n        // Select, multi select, select or text\n        options?: Option[]\n        apiPath?: string\n        // File, multi file\n        dropzoneOptions?: {\n          maxFiles?: number\n          maxSize?: number\n          accept?: Accept\n        }\n        // Password\n        isPasswordConfirmation?: boolean\n      }\n      description?: string\n      className?: string\n    }>\n  }>\n}\n\n// [T] Smart form field data\nexport type SmartFormFieldData = SmartFormData['templates'][number]['fields'][number]\n\n// [T] Smart form field type\nexport type SmartFormFieldType = SmartFormData['templates'][number]['fields'][number]['type']\n\n// [T] Schema options\nexport type SchemaOptions<T = FieldValues> = {\n  hiddenFields?: Record<string, boolean | undefined>\n  slots?: Record<string, z.ZodTypeAny>\n  refinement?: (arg: T, ctx: z.core.$RefinementCtx<T>) => void | Promise<void>\n}\n\n// [T] Smart form props\nexport interface SmartFormProps {\n  form: UseFormReturn\n  formData: SmartFormData\n  isUpdateMode?: boolean\n  isPending?: boolean\n  slots?: Record<string, React.ReactNode | undefined>\n  hiddenFields?: Record<string, boolean | undefined>\n  disabledFields?: Record<string, boolean | undefined>\n  submitButtonText?: string\n  actionButtonsClassName?: string\n  updateConfirmationDialogSlot?: React.ReactNode\n  cancel?: () => void\n  validate?: (fieldValues: FieldValues) => boolean | Promise<boolean>\n  submit?: (fieldValues: FieldValues) => void | Promise<void>\n}\n\n// [C] Default field values\nexport const defaultFieldValues: Record<SmartFormFieldType, string | number | boolean | null | string[]> = {\n  input: '', // string\n  textarea: '', // string\n  'phone-number': '', // string\n  number: '', // string | number\n  password: '', // string\n  'select-with-options': null, // string | null\n  'select-with-query': null, // string | null\n  'select-with-infinite-query': null, // string | null\n  'multi-select-with-options': [], // string[]\n  'multi-select-with-query': [], // string[]\n  'multi-select-with-infinite-query': [], // string[]\n  'autocomplete-with-options': '', // string\n  'autocomplete-with-query': '', // string\n  'autocomplete-with-infinite-query': '',\n  date: null, // Date | null\n  checkbox: false, // boolean\n  radio: null, // string | null\n  file: null, // File | ApiFile | null\n  'multi-file': [], // File[] | ApiFile[]\n  editor: '', // string\n  label: null,\n  slot: null\n} as const\n\n// [U] Get default form value\nexport const getDefaultFormValue = (formData: SmartFormData, slots?: FieldValues) => {\n  const defaultValues: FieldValues = {}\n  formData.templates.forEach((template) => {\n    template.fields.forEach((field) => {\n      // LABEL fields\n      if (field.type === 'label') {\n        return\n      }\n\n      // Other fields\n      defaultValues[field.code] = slots?.[field.code] ?? defaultFieldValues[field.type]\n    })\n  })\n  return defaultValues\n}\n\n// [U] Get form schema\nexport const getFormSchema = (formData: SmartFormData, schemaOptions?: SchemaOptions) => {\n  const shape: Record<string, ZodType> = {}\n\n  const passwordConfirmationFields: Array<{\n    code: string\n    referenceFields: NonNullable<\n      NonNullable<SmartFormData['templates'][number]['fields'][number]['config']>['referenceFields']\n    >\n  }> = []\n\n  formData.templates.forEach((template) => {\n    template.fields.forEach((field) => {\n      const { code, type, config: { validation, isPasswordConfirmation, referenceFields } = {} } = field\n\n      // Hidden fields\n      if (schemaOptions?.hiddenFields?.[code]) return\n\n      // Visible fields\n      switch (type) {\n        // input | textarea | phone-number | autocomplete | autocomplete-with-infinite-query | editor (string)\n        case 'input':\n        case 'textarea':\n        case 'phone-number':\n        case 'autocomplete-with-options':\n        case 'autocomplete-with-query':\n        case 'autocomplete-with-infinite-query':\n        case 'editor': {\n          let fieldSchema: ZodString | ZodPipe<ZodType> = z.string().trim()\n\n          if (!validation) {\n            shape[code] = fieldSchema\n            break\n          }\n\n          // Email\n          if (validation?.email) {\n            fieldSchema = fieldSchema.refine((value) => {\n              try {\n                if (!validation.required && !value) {\n                  return true\n                }\n                return Boolean(z.email().parse(value))\n              } catch {\n                return false\n              }\n            }, validation.email.message)\n\n            shape[code] = fieldSchema\n            break\n          }\n\n          // Required\n          if (validation.required) {\n            fieldSchema = fieldSchema.min(1, validation.required.message)\n          }\n\n          // Min\n          if (validation.min) {\n            fieldSchema = fieldSchema.min(validation.min.value as number, validation.min.message)\n          }\n\n          // Max\n          if (validation.max) {\n            fieldSchema = fieldSchema.max(validation.max.value as number, validation.max.message)\n          }\n\n          // Regex\n          if (validation.regex) {\n            const value = validation.regex.value as {\n              pattern: string\n              flags: string\n            }\n            fieldSchema = fieldSchema.regex(new RegExp(value.pattern, value.flags), validation.regex.message)\n          }\n\n          // Phone\n          if (validation.phone) {\n            fieldSchema = fieldSchema.refine(\n              (value) => (value ? isValidPhoneNumber(value) : true),\n              validation.phone.message\n            )\n          }\n\n          shape[code] = fieldSchema\n          break\n        }\n\n        // password (string)\n        case 'password': {\n          let fieldSchema: ZodString | ZodPipe<ZodType> = z.string().trim()\n\n          if (isPasswordConfirmation) {\n            if (referenceFields && referenceFields.length > 0) {\n              passwordConfirmationFields.push({\n                code,\n                referenceFields\n              })\n            }\n\n            shape[code] = fieldSchema\n            break\n          }\n\n          if (!validation) {\n            shape[code] = fieldSchema\n            break\n          }\n\n          // Required\n          if (validation.required) {\n            fieldSchema = fieldSchema.min(1, validation.required.message)\n          }\n\n          // Min\n          if (validation.min) {\n            fieldSchema = fieldSchema.min(validation.min.value as number, validation.min.message)\n          }\n\n          // Max\n          if (validation.max) {\n            fieldSchema = fieldSchema.max(validation.max.value as number, validation.max.message)\n          }\n\n          // Regex\n          if (validation.regex) {\n            const value = validation.regex.value as {\n              pattern: string\n              flags: string\n            }\n            fieldSchema = fieldSchema.regex(new RegExp(value.pattern, value.flags), validation.regex.message)\n          }\n\n          shape[code] = fieldSchema\n          break\n        }\n\n        // select-with-options | select-with-query | select-with-infinite-query | radio (string)\n        case 'select-with-options':\n        case 'select-with-query':\n        case 'select-with-infinite-query':\n        case 'radio': {\n          let fieldSchema: ZodNullable<ZodString> | ZodPipe<ZodNullable<ZodString>> = z.string().trim().nullable()\n\n          if (!validation) {\n            shape[code] = fieldSchema\n            break\n          }\n\n          // Required\n          if (validation.required) {\n            fieldSchema = fieldSchema.refine((value) => value != null, validation.required.message)\n          }\n\n          shape[code] = fieldSchema\n          break\n        }\n\n        // number (string | number)\n        case 'number': {\n          let fieldSchema: ZodNumber = z.number()\n\n          if (!validation) {\n            shape[code] = z.preprocess((value) => (Number.isNaN(Number(value)) ? 0 : Number(value)), fieldSchema)\n            break\n          }\n\n          // Required\n          if (validation.required) {\n            fieldSchema = fieldSchema.positive(validation.required.message)\n          }\n\n          // Min\n          if (validation.min) {\n            fieldSchema = fieldSchema.gte(validation.min.value as number, validation.min.message)\n          }\n\n          // Max\n          if (validation.max) {\n            fieldSchema = fieldSchema.lte(validation.max.value as number, validation.max.message)\n          }\n\n          shape[code] = z.preprocess((value) => (Number.isNaN(Number(value)) ? 0 : Number(value)), fieldSchema)\n          break\n        }\n\n        // multi-select-with-options | multi-select-with-query | multi-select-with-infinite-query (string[])\n        case 'multi-select-with-options':\n        case 'multi-select-with-query':\n        case 'multi-select-with-infinite-query': {\n          let fieldSchema: ZodArray<ZodString> = z.array(z.string())\n\n          if (!validation) {\n            shape[code] = fieldSchema\n            break\n          }\n\n          // Required\n          if (validation.required) {\n            fieldSchema = fieldSchema.min(1, validation.required.message)\n          }\n\n          shape[code] = fieldSchema\n          break\n        }\n\n        // date (iso string | Date)\n        case 'date': {\n          if (!validation) {\n            shape[code] = z.codec(z.union([z.iso.datetime(), z.date()]).nullable(), z.iso.datetime().nullable(), {\n              decode: (value) => (value ? (typeof value === 'string' ? value : value.toISOString()) : null),\n              encode: (value) => (value ? toDate(value) : null)\n            })\n            break\n          }\n\n          // Required\n          if (validation.required) {\n            shape[code] = z.codec(\n              z.union([z.iso.datetime(), z.date()]).nullable(),\n              z.iso.datetime().nullable().refine(Boolean, validation.required.message),\n              {\n                decode: (value) => (value ? (typeof value === 'string' ? value : value.toISOString()) : null),\n                encode: (value) => (value ? toDate(value) : null)\n              }\n            )\n            break\n          }\n          break\n        }\n\n        // checkbox (boolean)\n        case 'checkbox': {\n          shape[code] = z.boolean()\n          break\n        }\n\n        // file (File | UploadedFile | null)\n        case 'file': {\n          let fieldSchema: ZodType<File | UploadedFile | null> | ZodPipe<ZodType<File | UploadedFile | null>> =\n            z.custom<File | UploadedFile | null>()\n\n          if (!validation) {\n            shape[code] = fieldSchema\n            break\n          }\n\n          // Required\n          if (validation.required) {\n            fieldSchema = fieldSchema.refine((value) => Boolean(value), validation.required.message)\n          }\n\n          shape[code] = fieldSchema\n          break\n        }\n\n        // multi-file (Array<File | UploadedFile>)\n        case 'multi-file': {\n          let fieldSchema: ZodArray<ZodType<File | UploadedFile>> | ZodPipe<ZodArray<ZodType<File | UploadedFile>>> =\n            z.array(z.custom<File | UploadedFile>())\n\n          if (!validation) {\n            shape[code] = fieldSchema\n            break\n          }\n\n          // Required\n          if (validation.required) {\n            fieldSchema = fieldSchema.refine((value) => value.length > 0, validation.required.message)\n          }\n\n          shape[code] = fieldSchema\n          break\n        }\n\n        // Slot\n        case 'slot': {\n          const slotFieldSchema = schemaOptions?.slots?.[code]\n          if (slotFieldSchema) {\n            shape[code] = slotFieldSchema\n          }\n          break\n        }\n      }\n    })\n  })\n\n  let schema = z.object(shape)\n\n  if (passwordConfirmationFields.length > 0) {\n    schema = schema.superRefine((arg, ctx) => {\n      passwordConfirmationFields.forEach((passwordConfirmationField) => {\n        const { code, referenceFields } = passwordConfirmationField\n        const referenceField = referenceFields[0]\n        if (arg[code] !== arg[referenceField.code]) {\n          ctx.addIssue({\n            code: 'custom',\n            message: referenceField.message,\n            path: [code]\n          })\n        }\n      })\n    })\n  }\n\n  if (schemaOptions?.refinement) {\n    schema = schema.superRefine(schemaOptions.refinement)\n  }\n\n  return schema\n}\n",
      "type": "registry:file",
      "target": "src/components/organisms/smart-form/lib.ts"
    },
    {
      "path": "src/registry/new-york/organisms/smart-form/components/multi-file-field.tsx",
      "content": "import {\n  FileUpload,\n  FileUploadContent,\n  FileUploadInput,\n  FileUploadItem,\n  type FileUploadValue\n} from '@/components/molecules/file-upload'\nimport FieldContainer, { type FieldProps } from './field-container'\n\n// Component\nconst MultiFileField = ({ fieldData, disabledFields }: FieldProps) => {\n  // Template\n  return (\n    <FieldContainer fieldData={fieldData} disabledFields={disabledFields}>\n      {({ field, fieldState }) => (\n        <FileUpload\n          value={field.value}\n          dropzoneOptions={fieldData.config?.dropzoneOptions}\n          isDisabled={disabledFields?.[fieldData.code]}\n          onValueChange={field.onChange}\n        >\n          <FileUploadInput id={fieldData.code} aria-invalid={fieldState.invalid} />\n\n          <FileUploadContent>\n            {(field.value as FileUploadValue).map((value, index) => (\n              <FileUploadItem\n                // biome-ignore lint/suspicious/noArrayIndexKey: ignore\n                key={index}\n                index={index}\n                value={value}\n              />\n            ))}\n          </FileUploadContent>\n        </FileUpload>\n      )}\n    </FieldContainer>\n  )\n}\n\nexport default MultiFileField\n",
      "type": "registry:ui",
      "target": "src/components/organisms/smart-form/multi-file-field.tsx"
    },
    {
      "path": "src/registry/new-york/organisms/smart-form/components/multi-select-with-infinite-query-field.tsx",
      "content": "import React from 'react'\nimport { MultiSelect } from '@/components/molecules/multi-select'\nimport type { Option } from '@/types/base'\nimport FieldContainer, { type FieldProps } from './field-container'\n\n// Component\nconst MultiSelectWithInfiniteQueryField = ({ fieldData, disabledFields }: FieldProps) => {\n  // Todo: fetch infinite query and extract options\n\n  // Memos\n  const options = React.useMemo<Option[]>(() => {\n    return []\n  }, [])\n\n  // Template\n  return (\n    <FieldContainer fieldData={fieldData} disabledFields={disabledFields}>\n      {({ field }) => (\n        <MultiSelect\n          {...field}\n          options={options}\n          placeholder={`Select ${fieldData.label.toLowerCase()}`}\n          buttonTriggerProps={{\n            id: fieldData.code,\n            disabled: disabledFields?.[fieldData.code]\n          }}\n          onValueChange={field.onChange}\n        />\n      )}\n    </FieldContainer>\n  )\n}\n\nexport default MultiSelectWithInfiniteQueryField\n",
      "type": "registry:ui",
      "target": "src/components/organisms/smart-form/multi-select-with-infinite-query-field.tsx"
    },
    {
      "path": "src/registry/new-york/organisms/smart-form/components/multi-select-with-options-field.tsx",
      "content": "import { MultiSelect } from '@/components/molecules/multi-select'\nimport FieldContainer, { type FieldProps } from './field-container'\n\n// Component\nconst MultiSelectWithOptionsField = ({ fieldData, disabledFields }: FieldProps) => {\n  // Template\n  return (\n    <FieldContainer fieldData={fieldData} disabledFields={disabledFields}>\n      {({ field }) => (\n        <MultiSelect\n          {...field}\n          options={fieldData.config?.options ?? []}\n          placeholder={`Select ${fieldData.label.toLowerCase()}`}\n          buttonTriggerProps={{\n            id: fieldData.code,\n            disabled: disabledFields?.[fieldData.code]\n          }}\n          onValueChange={field.onChange}\n        />\n      )}\n    </FieldContainer>\n  )\n}\n\nexport default MultiSelectWithOptionsField\n",
      "type": "registry:ui",
      "target": "src/components/organisms/smart-form/multi-select-with-options-field.tsx"
    },
    {
      "path": "src/registry/new-york/organisms/smart-form/components/multi-select-with-query-field.tsx",
      "content": "import React from 'react'\nimport { MultiSelect } from '@/components/molecules/multi-select'\nimport type { Option } from '@/types/base'\nimport FieldContainer, { type FieldProps } from './field-container'\n\n// Component\nconst MultiSelectWithQueryField = ({ fieldData, disabledFields }: FieldProps) => {\n  // Todo: fetch query and extract options\n\n  // Memos\n  const options = React.useMemo<Option[]>(() => {\n    return []\n  }, [])\n\n  // Template\n  return (\n    <FieldContainer fieldData={fieldData} disabledFields={disabledFields}>\n      {({ field }) => (\n        <MultiSelect\n          {...field}\n          options={options}\n          placeholder={`Select ${fieldData.label.toLowerCase()}`}\n          buttonTriggerProps={{\n            id: fieldData.code,\n            disabled: disabledFields?.[fieldData.code]\n          }}\n          onValueChange={field.onChange}\n        />\n      )}\n    </FieldContainer>\n  )\n}\n\nexport default MultiSelectWithQueryField\n",
      "type": "registry:ui",
      "target": "src/components/organisms/smart-form/multi-select-with-query-field.tsx"
    },
    {
      "path": "src/registry/new-york/organisms/smart-form/components/number-field.tsx",
      "content": "import { NumberInput } from '@/components/molecules/number-input'\nimport FieldContainer, { type FieldProps } from './field-container'\n\n// Component\nconst NumberField = ({ fieldData, disabledFields }: FieldProps) => {\n  // Template\n  return (\n    <FieldContainer fieldData={fieldData} disabledFields={disabledFields}>\n      {({ field, fieldState }) => (\n        <NumberInput\n          {...field}\n          {...fieldData.config?.numberInputProps}\n          id={fieldData.code}\n          placeholder={`Enter ${fieldData.label.toLowerCase()}`}\n          disabled={disabledFields?.[fieldData.code]}\n          aria-invalid={fieldState.invalid}\n          onFieldChange={field.onChange}\n          onValueChange={(event) => field.onChange(event.value)}\n        />\n      )}\n    </FieldContainer>\n  )\n}\n\nexport default NumberField\n",
      "type": "registry:ui",
      "target": "src/components/organisms/smart-form/number-field.tsx"
    },
    {
      "path": "src/registry/new-york/organisms/smart-form/components/password-field.tsx",
      "content": "import { PasswordInput } from '@/components/molecules/password-input'\nimport FieldContainer, { type FieldProps } from './field-container'\n\n// Component\nconst PasswordField = ({ fieldData, disabledFields }: FieldProps) => {\n  // Template\n  return (\n    <FieldContainer fieldData={fieldData} disabledFields={disabledFields}>\n      {({ field, fieldState }) => (\n        <PasswordInput\n          {...field}\n          id={fieldData.code}\n          placeholder={`Enter ${fieldData.label.toLowerCase()}`}\n          disabled={disabledFields?.[fieldData.code]}\n          aria-invalid={fieldState.invalid}\n        />\n      )}\n    </FieldContainer>\n  )\n}\n\nexport default PasswordField\n",
      "type": "registry:ui",
      "target": "src/components/organisms/smart-form/password-field.tsx"
    },
    {
      "path": "src/registry/new-york/organisms/smart-form/components/phone-number-field.tsx",
      "content": "import { PhoneNumberInput } from '@/components/molecules/phone-number-input'\nimport FieldContainer, { type FieldProps } from './field-container'\n\n// Component\nconst PhoneNumberField = ({ fieldData, disabledFields }: FieldProps) => {\n  // Template\n  return (\n    <FieldContainer fieldData={fieldData} disabledFields={disabledFields}>\n      {({ field, fieldState }) => (\n        <PhoneNumberInput\n          {...field}\n          id={fieldData.code}\n          placeholder={`Enter ${fieldData.label.toLowerCase()}`}\n          disabled={disabledFields?.[fieldData.code]}\n          aria-invalid={fieldState.invalid}\n          onValueChange={field.onChange}\n        />\n      )}\n    </FieldContainer>\n  )\n}\n\nexport default PhoneNumberField\n",
      "type": "registry:ui",
      "target": "src/components/organisms/smart-form/phone-number-field.tsx"
    },
    {
      "path": "src/registry/new-york/organisms/smart-form/components/select-with-infinite-query-field.tsx",
      "content": "import React from 'react'\nimport { Combobox } from '@/components/ui/combobox'\nimport type { Option } from '@/types/base'\nimport FieldContainer, { type FieldProps } from './field-container'\n\n// Component\nconst SelectWithInfiniteQueryField = ({ fieldData, disabledFields }: FieldProps) => {\n  // Todo: fetch infinite query and extract options\n\n  // Memos\n  const options = React.useMemo<Option[]>(() => {\n    return []\n  }, [])\n\n  // Template\n  return (\n    <FieldContainer fieldData={fieldData} disabledFields={disabledFields}>\n      {({ field }) => (\n        <Combobox\n          {...field}\n          options={options}\n          placeholder={`Select ${fieldData.label.toLowerCase()}`}\n          buttonTriggerProps={{\n            id: fieldData.code,\n            disabled: disabledFields?.[fieldData.code]\n          }}\n          onValueChange={field.onChange}\n        />\n      )}\n    </FieldContainer>\n  )\n}\n\nexport default SelectWithInfiniteQueryField\n",
      "type": "registry:ui",
      "target": "src/components/organisms/smart-form/select-with-infinite-query-field.tsx"
    },
    {
      "path": "src/registry/new-york/organisms/smart-form/components/select-with-options-field.tsx",
      "content": "import { Combobox } from '@/components/ui/combobox'\nimport FieldContainer, { type FieldProps } from './field-container'\n\n// Component\nconst SelectWithOptionsField = ({ fieldData, disabledFields }: FieldProps) => {\n  // Template\n  return (\n    <FieldContainer fieldData={fieldData} disabledFields={disabledFields}>\n      {({ field }) => (\n        <Combobox\n          {...field}\n          options={fieldData.config?.options ?? []}\n          placeholder={`Select ${fieldData.label.toLowerCase()}`}\n          buttonTriggerProps={{\n            id: fieldData.code,\n            disabled: disabledFields?.[fieldData.code]\n          }}\n          onValueChange={field.onChange}\n        />\n      )}\n    </FieldContainer>\n  )\n}\n\nexport default SelectWithOptionsField\n",
      "type": "registry:ui",
      "target": "src/components/organisms/smart-form/select-with-options-field.tsx"
    },
    {
      "path": "src/registry/new-york/organisms/smart-form/components/select-with-query-field.tsx",
      "content": "import React from 'react'\nimport { Combobox } from '@/components/ui/combobox'\nimport type { Option } from '@/types/base'\nimport FieldContainer, { type FieldProps } from './field-container'\n\n// Component\nconst SelectWithQueryField = ({ fieldData, disabledFields }: FieldProps) => {\n  // Todo: fetch query and extract options\n\n  // Memos\n  const options = React.useMemo<Option[]>(() => {\n    return []\n  }, [])\n\n  // Template\n  return (\n    <FieldContainer fieldData={fieldData} disabledFields={disabledFields}>\n      {({ field }) => (\n        <Combobox\n          {...field}\n          options={options}\n          placeholder={`Select ${fieldData.label.toLowerCase()}`}\n          buttonTriggerProps={{\n            id: fieldData.code,\n            disabled: disabledFields?.[fieldData.code]\n          }}\n          onValueChange={field.onChange}\n        />\n      )}\n    </FieldContainer>\n  )\n}\n\nexport default SelectWithQueryField\n",
      "type": "registry:ui",
      "target": "src/components/organisms/smart-form/select-with-query-field.tsx"
    },
    {
      "path": "src/registry/new-york/organisms/smart-form/components/smart-form.tsx",
      "content": "import React from 'react'\nimport { type FieldValues, FormProvider } from 'react-hook-form'\nimport { Button } from '@/components/ui/button'\nimport {\n  Dialog,\n  DialogClose,\n  DialogContent,\n  DialogDescription,\n  DialogFooter,\n  DialogHeader,\n  DialogTitle\n} from '@/components/ui/dialog'\nimport { FieldDescription, FieldLegend, FieldSet } from '@/components/ui/field'\nimport { Spinner } from '@/components/ui/spinner'\nimport { cn } from '@/utils/ui'\nimport AutocompleteWithInfiniteQueryField from './autocomplete-with-infinite-query-field'\nimport AutocompleteWithOptionsField from './autocomplete-with-options-field'\nimport AutocompleteWithQueryField from './autocomplete-with-query-field'\nimport CheckboxField from './checkbox-field'\nimport DateField from './date-field'\nimport EditorField from './editor-field'\nimport type { FieldProps } from './field-container'\nimport FileField from './file-field'\nimport InputField from './input-field'\nimport type { SmartFormFieldType, SmartFormProps } from './lib'\nimport MultiFileField from './multi-file-field'\nimport MultiSelectWithInfiniteQueryField from './multi-select-with-infinite-query-field'\nimport MultiSelectWithOptionsField from './multi-select-with-options-field'\nimport MultiSelectWithQueryField from './multi-select-with-query-field'\nimport NumberField from './number-field'\nimport PasswordField from './password-field'\nimport PhoneNumberField from './phone-number-field'\nimport SelectWithInfiniteQueryField from './select-with-infinite-query-field'\nimport SelectWithOptionsField from './select-with-options-field'\nimport SelectWithQueryField from './select-with-query-field'\nimport TextareaField from './textarea-field'\n\nconst fieldComponents: Record<SmartFormFieldType, React.FC<FieldProps>> = {\n  input: InputField,\n  textarea: TextareaField,\n  number: NumberField,\n  'phone-number': PhoneNumberField,\n  password: PasswordField,\n  'select-with-options': SelectWithOptionsField,\n  'select-with-query': SelectWithQueryField,\n  'select-with-infinite-query': SelectWithInfiniteQueryField,\n  'multi-select-with-options': MultiSelectWithOptionsField,\n  'multi-select-with-query': MultiSelectWithQueryField,\n  'multi-select-with-infinite-query': MultiSelectWithInfiniteQueryField,\n  'autocomplete-with-options': AutocompleteWithOptionsField,\n  'autocomplete-with-query': AutocompleteWithQueryField,\n  'autocomplete-with-infinite-query': AutocompleteWithInfiniteQueryField,\n  date: DateField,\n  checkbox: CheckboxField,\n  radio: () => null,\n  file: FileField,\n  'multi-file': MultiFileField,\n  editor: EditorField,\n  label: () => null,\n  slot: () => null\n}\n\n// Smart form\nexport const SmartForm = ({\n  form,\n  formData,\n  isPending,\n  isUpdateMode = false,\n  slots,\n  hiddenFields,\n  disabledFields,\n  submitButtonText,\n  actionButtonsClassName,\n  updateConfirmationDialogSlot,\n  cancel,\n  validate,\n  submit\n}: SmartFormProps) => {\n  // Refs\n  const formValueRef = React.useRef<FieldValues>(() => form.getValues())\n\n  // States\n  const [isOpenConfirmationDialog, setIsOpenConfirmationDialog] = React.useState(false)\n\n  // Methods\n  const startValidation = async (formValue: FieldValues) => {\n    const isValidationPassed = (await validate?.(formValue)) ?? true\n    if (!isValidationPassed) return\n    formValueRef.current = formValue\n    return isUpdateMode ? setIsOpenConfirmationDialog(true) : submit?.(formValue)\n  }\n\n  const submitUpdateConfirmationDialog = async () => {\n    await submit?.(formValueRef.current)\n    if (isUpdateMode) {\n      setIsOpenConfirmationDialog(false)\n    }\n  }\n\n  // Template\n  if (form.formState.isLoading) {\n    return <Spinner className='size-6' />\n  }\n\n  return (\n    <FormProvider {...form}>\n      {/* Form */}\n      <form className='space-y-6' onSubmit={form.handleSubmit(startValidation)}>\n        {formData.templates.map((template) => (\n          <FieldSet key={template.code}>\n            {/* Form template label */}\n            <FieldLegend>{template.label}</FieldLegend>\n            {template.description && <FieldDescription>{template.description}</FieldDescription>}\n\n            {/* Form template fields */}\n            <div className={cn('grid grid-cols-12 gap-x-4 gap-y-6', template.className)}>\n              {template.fields.map((fieldData) => {\n                // Hidden\n                if (hiddenFields?.[fieldData.code]) {\n                  return null\n                }\n\n                // Label\n                if (fieldData.type === 'label') {\n                  return (\n                    <div key={fieldData.code} className={cn('col-span-full', fieldData.className)}>\n                      <span className='font-bold text-base text-muted-foreground'>{fieldData.label}</span>\n                    </div>\n                  )\n                }\n\n                // Slot\n                if (fieldData.type === 'slot') {\n                  return (\n                    <div key={fieldData.code} className={cn('col-span-full', fieldData.className)}>\n                      {slots?.[fieldData.code]}\n                    </div>\n                  )\n                }\n\n                // Others\n                const FieldComponent = fieldComponents[fieldData.type]\n                return <FieldComponent key={fieldData.code} fieldData={fieldData} disabledFields={disabledFields} />\n              })}\n            </div>\n          </FieldSet>\n        ))}\n\n        {/* Action buttons */}\n        {slots?.Actions === undefined ? (\n          <div className={cn('flex flex-col justify-stretch gap-4 xl:flex-row xl:justify-end', actionButtonsClassName)}>\n            <Button variant='outline' onClick={cancel}>\n              Cancel\n            </Button>\n\n            <Button isLoading={isPending || form.formState.isSubmitting} onClick={form.handleSubmit(startValidation)}>\n              {submitButtonText ?? 'Submit'}\n            </Button>\n          </div>\n        ) : (\n          slots.Actions\n        )}\n      </form>\n\n      {/* Update confirmation dialog */}\n      {isUpdateMode && (\n        <Dialog open={isOpenConfirmationDialog} onOpenChange={setIsOpenConfirmationDialog}>\n          <DialogContent className='max-w-2xl'>\n            <DialogHeader>\n              <DialogTitle>Update information</DialogTitle>\n              <DialogDescription>Are you sure that you want to save the updated information?</DialogDescription>\n            </DialogHeader>\n\n            {updateConfirmationDialogSlot && <main>{updateConfirmationDialogSlot}</main>}\n\n            <DialogFooter className='mt-6'>\n              <DialogClose asChild>\n                <Button type='button' variant='outline'>\n                  Cancel\n                </Button>\n              </DialogClose>\n\n              <Button isLoading={isPending || form.formState.isSubmitting} onClick={submitUpdateConfirmationDialog}>\n                Save\n              </Button>\n            </DialogFooter>\n          </DialogContent>\n        </Dialog>\n      )}\n    </FormProvider>\n  )\n}\n",
      "type": "registry:ui",
      "target": "src/components/organisms/smart-form/smart-form.tsx"
    },
    {
      "path": "src/registry/new-york/organisms/smart-form/components/textarea-field.tsx",
      "content": "import { Textarea } from '@/components/ui/textarea'\nimport FieldContainer, { type FieldProps } from './field-container'\n\n// Component\nconst TextareaField = ({ fieldData, disabledFields }: FieldProps) => {\n  // Template\n  return (\n    <FieldContainer fieldData={fieldData} disabledFields={disabledFields}>\n      {({ field, fieldState }) => (\n        <Textarea\n          {...field}\n          id={fieldData.code}\n          placeholder={`Enter ${fieldData.label.toLowerCase()}`}\n          disabled={disabledFields?.[fieldData.code]}\n          aria-invalid={fieldState.invalid}\n        />\n      )}\n    </FieldContainer>\n  )\n}\n\nexport default TextareaField\n",
      "type": "registry:ui",
      "target": "src/components/organisms/smart-form/textarea-field.tsx"
    }
  ]
}